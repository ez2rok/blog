[
  {
    "objectID": "posts/2023-08-17-post-with-code/index.html",
    "href": "posts/2023-08-17-post-with-code/index.html",
    "title": "Quarto Computations",
    "section": "",
    "text": "import numpy as np\na = np.arange(15).reshape(3, 5)\na\n\narray([[ 0,  1,  2,  3,  4],\n       [ 5,  6,  7,  8,  9],\n       [10, 11, 12, 13, 14]])"
  },
  {
    "objectID": "posts/2023-08-17-post-with-code/index.html#numpy",
    "href": "posts/2023-08-17-post-with-code/index.html#numpy",
    "title": "Quarto Computations",
    "section": "",
    "text": "import numpy as np\na = np.arange(15).reshape(3, 5)\na\n\narray([[ 0,  1,  2,  3,  4],\n       [ 5,  6,  7,  8,  9],\n       [10, 11, 12, 13, 14]])"
  },
  {
    "objectID": "posts/2023-08-17-post-with-code/index.html#matplotlib",
    "href": "posts/2023-08-17-post-with-code/index.html#matplotlib",
    "title": "Quarto Computations",
    "section": "Matplotlib",
    "text": "Matplotlib\n\nimport matplotlib.pyplot as plt\n\nfig = plt.figure()\nx = np.arange(10)\ny = 2.5 * np.sin(x / 20 * np.pi)\nyerr = np.linspace(0.05, 0.2, 10)\n\nplt.errorbar(x, y + 3, yerr=yerr, label='both limits (default)')\nplt.errorbar(x, y + 2, yerr=yerr, uplims=True, label='uplims=True')\nplt.errorbar(x, y + 1, yerr=yerr, uplims=True, lolims=True,\n             label='uplims=True, lolims=True')\n\nupperlimits = [True, False] * 5\nlowerlimits = [False, True] * 5\nplt.errorbar(x, y, yerr=yerr, uplims=upperlimits, lolims=lowerlimits,\n             label='subsets of uplims and lolims')\n\nplt.legend(loc='lower right')\nplt.show(fig)"
  },
  {
    "objectID": "posts/2023-08-17-post-with-code/index.html#plotly",
    "href": "posts/2023-08-17-post-with-code/index.html#plotly",
    "title": "Quarto Computations",
    "section": "Plotly",
    "text": "Plotly\n\nimport plotly.express as px\nimport plotly.io as pio\ngapminder = px.data.gapminder()\ngapminder2007 = gapminder.query(\"year == 2007\")\nfig = px.scatter(gapminder2007, \n                 x=\"gdpPercap\", y=\"lifeExp\", color=\"continent\", \n                 size=\"pop\", size_max=60,\n                 hover_name=\"country\")\nfig.show()"
  },
  {
    "objectID": "posts/2023-08-20-maximum_sum_subbarray/maximum-subarray-sum.html",
    "href": "posts/2023-08-20-maximum_sum_subbarray/maximum-subarray-sum.html",
    "title": "Different Perspectives on the The Maximum Sum Subarray Problem",
    "section": "",
    "text": "{{ badge }}\n\nIntroduction\nToday, we are going to solve the famous maximum subarray problem. The problem is stated as:\n\nGiven an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum.\n\nThis problem is usually solved with Kadane‚Äôs algorithm, the for a specific dynamic programming algorithm. However, we can actually solve this problem using a host of different algorithmic techniques:\n\nBrute Force\nDivide and Conquer\nDynamic Programming\nKadane‚Äôs algorithm\nSliding Window\n\nMost people ignore the most interesting part of the problem: that we can solve it in so many different ways! We just have to change our perspective and all of a sudden we can use a different algorithmic technique.\n\n\n\nTwo different perspectives. Source.\n\n\nWhen reading this article, I want your thought process to be something like:\n\nCool, we can solve this problem with a divide and conquer approach! Wait, this problem really can be solved with a dynamic programming algorithm, interesting. Hold up, it can be solved with the sliding window technique! No way!\n\nWe will show how some of these techniques are actually equivalent and are just doing the same thing while having different names. Pretty cool!\nFor each technique, I will explain the idea, give the time/space complexity, and provide a python implementation.\n\n\nBrute Force\nIdea: Generate all possible subarrays from the original array and find the one that has the greatest sum.\nTime Complexity: \\(O(n^2)\\)\nThe two nested for loops call line 6 of the algorithm \\(n (n+1)/2\\) times, meaning we have a runtime of \\(O(n^2)\\).\nSpace Complexity: \\(O(1)\\)\nWe don‚Äôt store anything except for the maximum sum seen so far.\nThe Algorithm:\n\ndef max_subarray_brute_force(nums):\n  \"\"\"Compute the maximum subarray with a brute force technique.\"\"\"\n\n  max_sum = -float('inf')\n  for i in range(len(nums)):\n    for j in range(i, len(nums)):\n      new_sum = sum(nums[i: j + 1])\n      max_sum = max(max_sum, new_sum)\n  return max_sum\n\n\n\nDivide And Conquer\nIdea: Let the contiguous array that results in the maximum sum be dennoted by nums[i, ..., j]. Then if we are looking at the array nums[low, ..., high], we know that the maximum subarray nums[i, ..., j] must be located in exactly one of three cases:\n\nentirely in the subarray nums[low, ..., mid] so that \\(low \\leq i \\leq j \\leq mid\\)\nentirely in the subarray nums[mid+1, ..., high] so that \\(mid+1 \\leq i \\leq j \\leq high\\)\ncrossing the midpoint so that \\(low \\leq i \\leq mid &lt; j \\leq high\\)\n\nwhere mid = (l + r) // 2.\nWe can find the maximum subarrays of nums[low, ..., mid] and nums[mid+1, ..., high] recursively because these two problems are smaller instances of the original problem of finding a maximum subarray. However, the problem of finding a maximum subarray that crosses the midpoint is not a smaller instance of our orignal problem because it has the added constraint that the subarray it chooses must cross the midpoint.\nSo the function max_crossing_subarray() will compute the maximum subarray that crosses the midpoint. It works by computing the left sum, the biggest possible sum we can get by starting at mid and repeatedly adding the number to the left of mid. Similarly, we compute the right sum, the biggest possible sum we can get by starting at mid and repeatedly adding the number to the right of mid. Then we add the left sum and right sum because together they are the greatest sums formed that must go through mid. This function returns the indices demarcating a maximum subarray that crosses the midpoint along with the sum of the values in this maximum subarray.\nLastly, max_subarray_helper() is a helper function that does most of the work organizing the three cases described above. It also returns the indices demarcating a maximum subarray that crosses the midpoint along with the sum of the values in this maximum subarray.\nFormally, we can express this as a recurrence relation:\n\\[\\begin{align}\n  dp[i][j]\n  &=\n  \\begin{cases}\n    0\n    &\n    \\text{if } i == j\n    \\\\\n    \\max \\Big\\{\n      dp[i][mid], \\hspace{2mm}\n      dp[mid+1][j], \\hspace{2mm}\n      \\text{max\\_crossing\\_subarray}(i, mid, j, nums)\n    \\Big\\}\n    &\n    \\text{else}\n  \\end{cases}\n\\end{align}\\]\nwhere\n\n\\(mid = i + (j - i) // 2\\)\n\\(dp[i][j]\\) is the maximum sum found in the subarray in nums[i, ..., j] (inclusive of \\(i,j\\)).\n\nTo compute the maximum subarray sum, simply compute \\(dp[0][len(nums)-1]\\).\nTime Complexity: \\(O(n log n)\\)\nLet \\(T(n)\\) be the runtime of max_subarray_helper() on an array of length \\(n\\). max_subarray_helper() has the recurrence relation \\[\\begin{align}\n  T(n) = 2T(n/2) + \\Theta(n).\n\\end{align}\\] The term \\(2T(n/2)\\) comes from the two recursive calls that are each made on half the input, specifically on nums[low, ..., mid] and nums[mid+1, ..., high]. The term \\(\\Theta(n)\\) comes from calling max_crossing_subarray() which runs in linear time. Solving this equation with the master method, we find that\n\\[\\begin{align}\n  T(n) = O(n log n).\n\\end{align}\\]\nSpace Complexity: \\(O(1)\\)\nWe only store constants like low, high, left_low, left_high, left_sum, etc. Note: this space complexity does not take into account the \\(O(log n)\\) space used by the recursive stack.\nThe Algorithm:\n\ndef max_crossing_subarray(low, mid, high, nums):\n  \"\"\"Compute the maximum subarray that crosses the midpoint.\"\"\"\n    \n  # get largest left sum that ends at m, ie get largest sum of the form nums[i:mid+1] for some i\n  left_sum = -float('inf')\n  sum_ = 0\n  for i in range(mid, low - 1, -1):\n    sum_ += nums[i]\n    if sum_ &gt; left_sum:\n      left_sum = sum_\n      max_left = i\n          \n  # get largest right sum that starts at m, ie get largest sum of the form nums[mid+1:j] for some j\n  right_sum = -float('inf')\n  sum_ = 0\n  for j in range(mid+1, high+1):\n    sum_ += nums[j]\n    if sum_ &gt; right_sum:\n      right_sum = sum_\n      max_right = j\n  \n  return (max_left, max_right, left_sum + right_sum)\n\n\ndef max_subarray_helper(low, high, nums):\n  \"\"\"Find the maximum subarray in nums[low, ..., high].\"\"\"\n\n  if low == high: # base case\n    return (low, high, nums[low])\n  \n  # compute the maximum subarray to left of mid, to the right of mid, and crossing mid\n  mid = low + (high - low) // 2\n  left_low, left_high, left_sum = max_subarray_helper(low, mid, nums)\n  right_low, right_high, right_sum = max_subarray_helper(mid + 1, high, nums)\n  cross_low, cross_high, cross_sum = max_crossing_subarray(low, mid, high, nums)\n  \n  if left_sum &gt;= right_sum and left_sum &gt;= cross_sum: # if left_sum is the biggest\n    return left_low, left_high, left_sum\n  if right_sum &gt;= left_sum and right_sum &gt;= cross_sum: # if right_sum is the biggest\n    return right_low, right_high, right_sum\n  return cross_low, cross_high, cross_sum\n\n\ndef max_subarray_div_and_conq(nums):  \n  \"\"\"Compute the maximum subarray with a divide and conquer technique.\"\"\"\n  \n  low, high = 0, len(nums) - 1\n  _, _, max_sum = max_subarray_helper(low, high, nums)\n  return max_sum\n\n\n\nDynamic Programming\nIdea: If we already know the largest sum in nums[0:i], then the largest sum in nums[0:i+1] is nums[0:i] + nums[i] if nums[0:i] is positive. If nums[0:i] is negative, adding it to nums[i] would just make it smaller, so the largest sum in nums[0:i+1] is just nums[i]. This idea naturally lends itself to dynamic programming. In particular, this problem has the recurrence:\n\\[\\begin{align*}\n  dp[i]\n  &=\n  \\begin{cases}\n    0 & \\text{if } i &lt; 0\n    \\\\\n    nums[i] + dp[i-1] & dp[i-1] &gt; 0\n    \\\\\n    nums[i] & \\text{else}\n  \\end{cases}\n\\end{align*}\\]\nwhere \\(dp[i]\\) is the maximum sum obtained from contigious subarrays in the first \\(i\\) elements of nums. This recurrence relation can be written more succinctly as\n\\[\\begin{align*}\n  dp[i]\n  &=\n  \\begin{cases}\n    0 & \\text{if } i &lt; 0\n    \\\\\n    nums[i] + \\max(dp[i-1], 0) & \\text{else}\n  \\end{cases}\n\\end{align*}\\]\nWe will implement a bottom-up solution to this dynamic programming problem, meaning we compute the maximum sum in the first element of nums, the first two elements of nums, the first three elements of nums, etc. At each iteration, we compute the maximum sum seen so far.\nTo compute the maximum subarray sum, simply compute \\(dp[len(nums)-1]\\).\nTime Complexity: \\(O(n)\\)\nIt takes constant time to compute a single entry in the table \\(dp\\). And because there are \\(n\\) entries in the table, it will take \\(O(n)\\) time to fill in the entire table.\nSpace Complexity: \\(O(n)\\)\nThe table has \\(n\\) entries so this algorithim take \\(O(n)\\) space.\nThe Algorithm:\n\ndef max_subarray_dp(nums):\n  \"\"\"compute the maximum subarray with a dynamic programming technique\"\"\"\n\n  dp = [0] * (len(nums))\n  dp[0] = max_sum = nums[0]\n\n  for i in range(1, len(nums)):\n    dp[i] = nums[i] + max(dp[i-1], 0)\n    max_sum = max(max_sum, dp[i])\n  return max_sum\n\n\n\nKadane‚Äôs Algorithm\nIdea: Kadane‚Äôs algorithm is the exact same as the dynamic programming solution but it uses \\(O(1)\\) space instead of \\(O(n)\\) space. Recall the recurrence relation for this problem is \\[\\begin{align*}\n  dp[i]\n  &=\n  \\begin{cases}\n    0 & \\text{if } i &lt; 0\n    \\\\\n    nums[i] + \\max(dp[i-1], 0) & \\text{else}\n  \\end{cases}\n\\end{align*}\\] A closer analysis reveals that to compute \\(dp[i]\\), we only need \\(dp[i-1]\\). We don‚Äôt need any of the other previous entries of \\(dp\\). This means we do not to store the entire \\(dp\\) table (which takes \\(O(n)\\) space) and instead can store just \\(dp[i-1]\\) as current_sum. This is Kadane‚Äôs algorithm.\nAgain, to compute the maximum subarray sum, simply compute \\(dp[len(nums)-1]\\).\nTime Complexity: \\(O(n)\\)\nWe must compute \\(n\\) different values of \\(dp\\).\nSpace Complexity: \\(O(1)\\)\nWe only store only the previous sum to compute the current sum.\nThe Algorithm:\n\ndef max_subarray_kadane(nums):\n  \"\"\"compute the maximum subarray with the Kadane's algorithm technique\"\"\"\n  \n  max_sum = current_sum = nums[0]\n  for i in range(1, len(nums)):\n    current_sum = nums[i] + max(current_sum, 0)\n    max_sum = max(max_sum, current_sum)\n  return max_sum\n\n\n\nSliding Window\nIdea: Use two pointers low and high to maintain a sliding window across the array. At every iteration, move high one to right and add the new element to the running sum sum_. If the sum is less than the new element nums[high], then we would get a higher sum just by starting our sum from nums[high]. So we want to keep on moving the left pointer until sum_ &lt; nums[high] is no longer true; this is expressed with a while loop. (A closer look reveals that if we ever have sum_ &lt; nums[high] and wish to start our sum from nums[high], we can immediately move the left pointer to nums[high] if sum_ &lt; nums[high], no need for a while loop; this optimized version is commented out. Also, at every iteration we record the maximum sum so once we‚Äôre done iterating through the array, we can just return the maximum sum.\nTime Complexity: \\(O(n)\\)\nWe iterate through the entire array once by moving two pointers.\nSpace Complexity: \\(O(1)\\)\nTrivial.\nThe Algorithm:\n\ndef max_subarray_sliding_window(nums):\n  \"\"\"compute the maximum subarray with a sliding window technique\"\"\"\n\n  low, sum_ = 0, 0\n  max_sum = -float('inf')\n  \n  for high in range(len(nums)):\n    sum_ += nums[high]\n    \n    while sum_ &lt; nums[high]:\n      sum_ -= nums[low]\n      low += 1\n\n    # optimized version\n    # if sum_ &lt; nums[high]:\n    #   sum_ = nums[high]\n    #   low = high\n  \n    max_sum = max(max_sum, sum_)\n  return max_sum\n\n\n\nComparison\nTime & Space Complexity: We can easily analyse the space and runtime complexity of each algorithm.\n\n\n\nTechnique\nRuntime ¬†\nSpace\n\n\n\n\nBrute Force\n\\(O(n^2)\\)\n\\(O(1)\\)\n\n\nDivide & Conquer\n\\(O(n logn)\\)\n\\(O(1)\\)\n\n\nSliding Window\n\\(O(n)\\)\n\\(O(1)\\)\n\n\nDynamic Programming\n\\(O(n)\\)\n\\(O(n)\\)\n\n\nKadane‚Äôs Algorithm\n\\(O(n)\\)\n\\(O(1)\\)\n\n\n\nSliding Window & Kadane‚Äôs Algorithm: If you take a closer look, you can see that Sliding Window and Kadane‚Äôs Algorithm are essentially the same exact algorithm but implemented differently.\nRecurrence Relations: Note that DP/Kadane‚Äôs algorithm can be expressed by the recurrence relation\n\\[\\begin{align*}\n  dp[i]\n  &=\n  \\begin{cases}\n    0 & \\text{if } i &lt; 0\n    \\\\\n    nums[i] + \\max(dp[i-1], 0) & \\text{else}\n  \\end{cases}\n\\end{align*}\\]\nbut the divide and conquer technique can be expressed by the recurrence relation\n\\[\\begin{align}\n  dp[i][j]\n  &=\n  \\begin{cases}\n    0\n    &\n    \\text{if } i == j\n    \\\\\n    \\max \\Big\\{\n      dp[i][mid], \\hspace{2mm}\n      dp[mid+1][j], \\hspace{2mm}\n      \\text{max\\_crossing\\_subarray}(i, mid, j, nums)\n    \\Big\\}\n    &\n    \\text{else}\n  \\end{cases}\n\\end{align}\\]\nBoth recurrences display optimal substructure, meaning the solution to the original problem can be achieved by finding the optimal solution to smaller subproblems. Yet there are differences. The first recurrence is 1D while the second recurrence is 2D. This explains why the first recurrence results in an \\(O(n)\\) algorithm and the second recurrence results in an \\(O(n log n )\\) algorithm.\n\n\nTiming Maximum Subarray Algorithms\nThe table above states the worst case runtime of various maximum subarray algorithms. However, how many seconds does it actually take to compute the maximum subarray sum for each algorithm? How much faster is one algorithm than another?\nBelow I run the five different maximum subarray algorithms and time their runtime on inputs of different sizes. Every element of the input array is randomly (uniformly) choosen from the interval \\([-100, 100]\\).\n\n\n\n\n\nNote that, as expected, the \\(O(n^2)\\) brute force algorithm is the slowest, the \\(O(n log n)\\) divide and conquer algorithm is the second slowest, and the \\(O(n)\\) sliding window algorithm, (non-constant space) dynamic programming algorithm, and Kadane‚Äôs algorithm are the fastest. This emperically confirms what we showed via theory.\n\n\nWorks Cited\n\nCormen, Thomas H, et al.¬†Introduction to Algorithms. 3rd ed., Cambridge (Massachusetts) ; London, MIT Press, 2007, pp.¬†68‚Äì74.\nFabr√©, Maarten. ‚ÄúPlot Timings for a Range of Inputs.‚Äù Code Review Stack Exchange, 9 June 2017, codereview.stackexchange.com/a/165362/260966. Accessed 25 July 2022.\nLeetcode. ‚ÄúMaximum Subarray.‚Äù Leetcode.com, leetcode.com/problems/maximum-subarray/discuss/. Accessed 25 July 2022.\n\n\n\n\n\nReusehttps://creativecommons.org/licenses/by/4.0/CitationBibTeX citation:@online{turok2023,\n  author = {Turok, Eitan},\n  title = {Different {Perspectives} on the {The} {Maximum} {Sum}\n    {Subarray} {Problem}},\n  date = {2023-08-20},\n  url = {https://github.com/ez2rok/blog/posts/2023-08-20-maximum_sum_subbarray/maximum-subarray-sum.html},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nTurok, Eitan. 2023. ‚ÄúDifferent Perspectives on the The Maximum Sum\nSubarray Problem.‚Äù August 20, 2023. https://github.com/ez2rok/blog/posts/2023-08-20-maximum_sum_subbarray/maximum-subarray-sum.html."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Algorithmic Mutterings",
    "section": "",
    "text": "Hello üëã! I‚Äôm Eitan Turok. I like building things. And I am an obsessive learner üìö.   I am majoring in CS and Applied Mathematics at Columbia University. I am generally interested in deep learning (efficient training, geometric DL, interpretability) and theoretical CS (fine-grained complexity, graph algorithms).   I do research under Prof Itsik Pe‚Äôer predicting diseases from the microbiome with non-Eculdidean embeddings. I also do research under Prof Josh Alman on the fine-grained complexity of dynamic programming problems.\n\n\n\n\n\n\n\nBlog Posts\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\nDifferent Perspectives on the The Maximum Sum Subarray Problem\n\n\n\n\n\n\n\ndynamic-programming\n\n\nalgorithms\n\n\n\n\nFive algorithms to solve the maximum sum subarray problem. Each with a different algorithmic technique.\n\n\n\n\n\n\nAug 20, 2023\n\n\nEitan Turok\n\n\n\n\n\n\n  \n\n\n\n\nQuarto Computations\n\n\n\n\n\n\n\n\n\n\n\n\nAug 17, 2023\n\n\nEitan Turok\n\n\n\n\n\n\n  \n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\n\n\nAug 15, 2023\n\n\nEitan Turok, Eitan Turok\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About me!"
  },
  {
    "objectID": "posts/2023-08-15-welcome/index.html",
    "href": "posts/2023-08-15-welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "{{ badge }}\nThis is the first post in my Quarto blog. Welcome!\n\nI‚Äôm excited to start blogging!\n\n\n\n\n\nReusehttps://creativecommons.org/licenses/by/4.0/CitationBibTeX citation:@online{turok2023,\n  author = {Turok, Eitan and Turok, Eitan},\n  title = {Welcome {To} {My} {Blog}},\n  date = {2023-08-15},\n  url = {https://github.com/ez2rok/blog/posts/2023-08-15-welcome},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nTurok, Eitan, and Eitan Turok. 2023. ‚ÄúWelcome To My Blog.‚Äù\nAugust 15, 2023. https://github.com/ez2rok/blog/posts/2023-08-15-welcome."
  }
]